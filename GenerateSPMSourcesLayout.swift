//#!/usr/bin/swift

//
//  generate_spm_sources_layout.swift
//
//  Created by Petro Rovenskyy on 09.03.2021.
//
//  Swift Package Manager [has some strict requirements](https://github.com/apple/swift-package-manager/blob/main/Documentation/Usage.md#creating-c-language-targets) to source files layout.
//  We can gain SPM support with minimal project structure changes by applying an autogenerated layout based on symbolic links technics.
//  SPM related files (public headers) located under `Texture/Source/include` folder.
//  SPM target which support IGListKit located under `Texture/AsyncDisplayKitIGListKit` folder which hold symbolic link to `Soure` folder.
//
//  You should **NEVER** modify it manually nor inlude to Xcode's project.
//   ### Generate SPM layout
//   1. From **project's root** run:
//     `swift scripts/generate_spm_sources_layout.swift`
//   2. Commit Changes
//   Repeate those steps each time you delete/add project's files. **Make sure** to have this CI step which will check that `generate_spm_sources_layout.swift` is not broken.

import Foundation

// MARK: Defines

struct SearchPath {
    
    enum SearchCfg: UInt8 {
        
        case currentDirOnly
        case includeSubirectories
    }
    
    let path: String
    let isDir: Bool
    let searchPattern: SearchCfg
    
    init(path: String,
         isDir: Bool,
         searchPattern: SearchCfg = .includeSubirectories) {
        self.path = path
        self.isDir = isDir
        self.searchPattern = searchPattern
    }
}

let exludeFilePaths: [SearchPath] = [
    .init(path: "Sources/Include", isDir: true)
]

let publicHeadersLayout: [SearchPath] = [
    .init(path: "Sources", isDir: true, searchPattern: .currentDirOnly),
    .init(path: "Sources/Details", isDir: true),
    .init(path: "Sources/Layout", isDir: true),
    .init(path: "Sources/Base", isDir: true),
    .init(path: "Sources/Debug", isDir: true),
    .init(path: "Sources/TextKit/ASTextNodeTypes.h", isDir: false),
    .init(path: "Sources/TextKit/ASTextKitComponents.h", isDir: false),
    .init(path: "Sources/TextExperiment/Component", isDir: true, searchPattern: .currentDirOnly),
    .init(path: "Sources/TextExperiment/String/ASTextAttribute.h", isDir: false),
]

// MARK: Helpers

func publicHeadersOnlyFromCurrent(directory path: String) -> [String] {
    do {
        return try FileManager.default.contentsOfDirectory(atPath: path)
            .filter { $0.hasSuffix(".h") }
            .compactMap { item in path + "/" + item }
    } catch {
        fatalError("Could not find public headers \(error)")
    }
}

func publicHeadersIncludingSubdirectoriesFrom(directory path: String) -> [String] {
    let dirItems: FileManager.DirectoryEnumerator? = FileManager.default.enumerator(atPath: path)
    let sourceFilePaths: [String] = dirItems?.allObjects as! [String]
    var publicHeaders: [String] = []
    sourceFilePaths
        .filter {$0.hasSuffix(".h") }
        .forEach { (sourceItemPath) in
            let temp = path + "/" + sourceItemPath
            // Skip files if needed
            guard 
                exludeFilePaths.allSatisfy({ !temp.contains($0.path) })
            else { return }
            // Validate that path make sence and file exists
            guard 
                FileManager.default.fileExists(atPath: temp)
            else { fatalError("Could not find source file at path:\n \(path)") }
            publicHeaders.append(temp)
        }
    return publicHeaders
}

func privateHeadersAndImpl(sources: String, publicHeaders: [String]) -> [String] {
    var privateHeadersAndSources: [String] = []
    let dirItems: FileManager.DirectoryEnumerator? = FileManager.default.enumerator(atPath: sources)
    let sourceFilePaths: [String] = dirItems?.allObjects as! [String]
    sourceFilePaths.forEach { (path) in
        let fullPath = sources +  "/" + path
        var isDir: ObjCBool = false
        guard 
            FileManager.default.fileExists(atPath: fullPath, isDirectory: &isDir)
        else { fatalError("Source file does not exist : \(fullPath)") }
        // filter folders
        if isDir.boolValue { return }
        // filter public headers
        if publicHeaders.contains(fullPath) { return }
        // collect sources
        if fullPath.hasSuffix(".h") ||
           fullPath.hasSuffix(".m") ||
           fullPath.hasSuffix(".mm") {
            // Collect path
            privateHeadersAndSources.append(fullPath)
        }
    }
    return privateHeadersAndSources
}

func createSymLinks(for sources: [String], atPath: String) {
    sources.forEach { (sourcePath) in
        let name = URL(string: sourcePath)!.lastPathComponent
        let symLinkPath = atPath + "/" + name
        do {
            try FileManager.default.createSymbolicLink(atPath: symLinkPath, withDestinationPath: sourcePath)
        } catch {
            fatalError(error.localizedDescription)
        }
    }
}

func cleanup(at: String) {
    do {
        let paths: [String] = try FileManager.default.contentsOfDirectory(atPath: at)
        for path in paths {
            try FileManager.default.removeItem(atPath: "\(at)/\(path)")
        }
    } catch {
        fatalError(error.localizedDescription)
    }
}

func generateSPM(publicHeadersPath: String, sourcesPath: String) {
    // 1. Delete all existing symlinks
    cleanup(at: publicHeadersPath)
    try! FileManager.default.createDirectory(atPath: publicHeadersPath,
                                             withIntermediateDirectories: true,
                                             attributes: nil)
    // 2. Find all public headers
    var publicHeaders: [String] = []
    publicHeadersLayout.forEach { (headerLayout) in
        let fPath = projectRoot + "/" + headerLayout.path
        // 2.1. Is it path to a file and not folder?
        // Just grab it.
        guard
            headerLayout.isDir
        else {
            assert(FileManager.default.fileExists(atPath: fPath), "Could not find source file at path:\n \(fPath)")
            publicHeaders.append(fPath)
            return
        }
        // 2.2. It's a folder path, search.
        switch headerLayout.searchPattern {
        case .currentDirOnly:
            let currentFolder = publicHeadersOnlyFromCurrent(directory: fPath)
            publicHeaders.append(contentsOf: currentFolder)
        case .includeSubirectories:
            let subfolders = publicHeadersIncludingSubdirectoriesFrom(directory: fPath)
            publicHeaders.append(contentsOf: subfolders)
        }
    }
    
    // 3. Create symbolic links for public headers
    let relativeHeadersPath = publicHeaders.map { (headerPath) -> String in
        let relativePath  = headerPath.replacingOccurrences(of: projectRoot, with: "../../")
        return relativePath
    }
    createSymLinks(for: relativeHeadersPath, atPath: publicHeadersPath)
    
    // 4. Find private headers and impl files.
    let privateSources: [String] = privateHeadersAndImpl(sources: sourceFolder, publicHeaders: publicHeaders)
    let relativeSourcesPath = privateSources.map { (sourcePath) -> String in
        let relativePath  = sourcePath.replacingOccurrences(of: projectRoot, with: "../../")
        return relativePath
    }
    
    // 5. Create symbolic links for source files
    createSymLinks(for: relativeSourcesPath, atPath: sourcesPath)
}

// MARK: Script start

print("Script start...")
print("===========================================================")
let projectRoot: String = FileManager.default.currentDirectoryPath
let sourceFolder: String = projectRoot + "/Sources"

// MARK: Generate AsyncDisplayKit SPM layout
let asdkPublicHeadersPath = projectRoot + "/Sources/Include"
let asdkSourcesPath = projectRoot + "/Sources"

print("ProjectRoot path: \(projectRoot)")
print("sourceFolder path: \(sourceFolder)")
print("asdkPublicHeadersPath path: \(asdkPublicHeadersPath)")
print("asdkSourcesPath path: \(asdkSourcesPath)")

print("===========================================================")

generateSPM(publicHeadersPath: asdkPublicHeadersPath, sourcesPath: asdkSourcesPath)

// MARK: Script end
